<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Meteor Madness – Real-Time Orbits</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  html, body, canvas { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:black; }
  #infoPanel { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; background:rgba(0,0,0,0.6); padding:5px 10px; border-radius:5px; z-index:1; }
</style>
</head>
<body>
<div id="infoPanel">Click an asteroid to see details</div>
<canvas id="renderCanvas"></canvas>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<script>
// ---------- ENGINE & SCENE ----------
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer:true, stencil:true});
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0,0,0,1);

// ---------- CAMERA ----------
const camera = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0, 50, -600), scene);
camera.attachControl(canvas, true);
camera.speed = 2;
camera.angularSensibility = 5000;
camera.keysUp.push(87,38);
camera.keysDown.push(83,40);
camera.keysLeft.push(65,37);
camera.keysRight.push(68,39);
camera.keysUpward = [69,32];
camera.keysDownward = [81,17];

// ---------- SUN ----------
const SUN_RADIUS = 50;
const sun = BABYLON.MeshBuilder.CreateSphere("sun", {diameter:SUN_RADIUS*2, segments:64}, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveTexture = new BABYLON.Texture("assets/sun_8k.jpg", scene);
sunMat.diffuseColor = new BABYLON.Color3(0,0,0);
sun.material = sunMat;
sun.position = BABYLON.Vector3.Zero();
const glow = new BABYLON.GlowLayer("glow", scene);
glow.intensity = 0.8;
const sunLight = new BABYLON.DirectionalLight("sunLight", new BABYLON.Vector3(-1,-0.5,-1), scene);
sunLight.position = sun.position.clone();
sunLight.intensity = 2;

// ---------- EARTH ----------
const EARTH_RADIUS = 5;
const ORBIT_RADIUS = 300; // Babylon units
const earth = BABYLON.MeshBuilder.CreateSphere("earth",{diameter:EARTH_RADIUS*2, segments:64},scene);
const earthMat = new BABYLON.StandardMaterial("earthMat", scene);
earthMat.diffuseTexture = new BABYLON.Texture("assets/earth_day_8k.jpg", scene);
earthMat.specularColor = new BABYLON.Color3(0,0,0);
earth.material = earthMat;

// ---------- EARTH ORBIT TRACE ----------
const earthOrbitPoints = [];
const EARTH_ORBIT_SEGMENTS = 200;
for(let i=0;i<=EARTH_ORBIT_SEGMENTS;i++){
    const angle = i/EARTH_ORBIT_SEGMENTS*2*Math.PI;
    earthOrbitPoints.push(new BABYLON.Vector3(
        ORBIT_RADIUS*Math.cos(angle),
        0,
        ORBIT_RADIUS*Math.sin(angle)
    ));
}
BABYLON.MeshBuilder.CreateLines("earthOrbit", {points: earthOrbitPoints}, scene).color = new BABYLON.Color3(0,1,0);

// ---------- GUI ----------
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
const caution = new BABYLON.GUI.TextBlock();
caution.text = "⚠ Asteroid sizes proportional to Earth/Sun, not real scale";
caution.color = "yellow";
caution.fontSize = 14;
caution.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
caution.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
caution.paddingRight = 10;
caution.paddingBottom = 10;
gui.addControl(caution);

const keyboardGuide = new BABYLON.GUI.TextBlock();
keyboardGuide.text = 
`Controls:
Move: W/A/S/D or Arrows
Up: E/Space
Down: Q/Ctrl
Click Asteroid: Follow
Click Empty Space: Release
Mouse: Look Around`;
keyboardGuide.color = "white";
keyboardGuide.fontSize = 14;
keyboardGuide.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
keyboardGuide.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
keyboardGuide.paddingRight = 10;
keyboardGuide.paddingTop = 10;
gui.addControl(keyboardGuide);

// ---------- ASTEROIDS ----------
const asteroids = [];
let highlightedAsteroid = null;
const asteroidCount = 50;

// ---------- REAL-TIME ORBIT CONSTANTS ----------
const SECONDS_PER_DAY = 86400;
const SIMULATION_SPEED = 1; // 1 second = 1 second (true real-time)
const EARTH_PERIOD = 365.25; // days
const EARTH_SPEED = 2*Math.PI / EARTH_PERIOD; // radians per day
let earthAngle = Math.random()*Math.PI*2;

// ---------- ASTEROID ORBIT CREATION ----------
function createAsteroidOrbit(asteroid){
    const points = [];
    const steps = 200;
    for(let i=0;i<=steps;i++){
        const angle = i/steps*2*Math.PI;
        const x = asteroid.radius*Math.cos(angle);
        const y = asteroid.radius*Math.sin(angle)*Math.sin(BABYLON.Tools.ToRadians(asteroid.inclination));
        const z = asteroid.radius*Math.sin(angle)*Math.cos(BABYLON.Tools.ToRadians(asteroid.inclination));
        points.push(new BABYLON.Vector3(x,y,z));
    }
    const line = BABYLON.MeshBuilder.CreateLines("orbit_"+asteroid.mesh.name,{points},scene);
    line.color = new BABYLON.Color3(1,0.5,0);
    asteroid.orbitLine = line;
}

// ---------- FETCH NEO DATA ----------
async function fetchAsteroids(){
    try{
        const response = await fetch(`https://api.nasa.gov/neo/rest/v1/neo/browse?api_key=dJ0igmngCm6cguSndVB6bkW1LVcDa8DDhjS6OqWo`);
        const data = await response.json();
        const neoList = data.near_earth_objects.slice(0,asteroidCount);

        neoList.forEach((neo,i)=>{
            const distanceFactor = 0.7 + Math.random()*0.6;
            const radius = ORBIT_RADIUS * distanceFactor;
            const inclination = parseFloat(neo.orbital_data.inclination)|| (Math.random()*20-10);

            // Angular speed using Kepler's third law
            const GM = 1; // scaled unit
            const period = 2*Math.PI * Math.sqrt(Math.pow(radius/100,3)/GM); // arbitrary scaling for visualization
            const speed = 2*Math.PI / period; // radians per day

            const size = 0.5 + Math.random()*1.5;
            const mat = new BABYLON.StandardMaterial("mat"+i,scene);
            mat.diffuseTexture = new BABYLON.Texture("assets/asteroid_8k.jpg",scene);

            const asteroid = BABYLON.MeshBuilder.CreatePolyhedron("ast"+i,{type:2,size:size,flat:false},scene);
            asteroid.material = mat;
            asteroid.rotationSpeed = new BABYLON.Vector3(
                (Math.random()-0.5)*0.02,
                (Math.random()-0.5)*0.02,
                (Math.random()-0.5)*0.02
            );

            const label = new BABYLON.GUI.TextBlock();
            label.text = neo.name;
            label.color = "white";
            label.fontSize = 12;
            label.outlineWidth = 1;
            label.outlineColor = "black";
            gui.addControl(label);
            label.linkWithMesh(asteroid);
            label.linkOffsetY = -15 - size*10;

            const asteroidObj = {
                mesh: asteroid,
                radius,
                inclination,
                angle: Math.random()*Math.PI*2,
                speed,
                label,
                orbitLine: null
            };
            asteroids.push(asteroidObj);
            createAsteroidOrbit(asteroidObj);
        });

    }catch(err){
        console.error("Failed to fetch asteroids", err);
    }
}
fetchAsteroids();

// ---------- HIGHLIGHT ----------
function highlightAsteroid(a){
    if(highlightedAsteroid){
        highlightedAsteroid.mesh.material.emissiveColor = BABYLON.Color3.Black();
        if(highlightedAsteroid.orbitLine) highlightedAsteroid.orbitLine.color = new BABYLON.Color3(1,0.5,0);
    }
    highlightedAsteroid = a;
    if(a){
        a.mesh.material.emissiveColor = new BABYLON.Color3(0,1,1);
        if(a.orbitLine) a.orbitLine.color = new BABYLON.Color3(0,1,1);
    }
}

// ---------- POINTER ----------
scene.onPointerObservable.add((pi)=>{
    if(pi.type === BABYLON.PointerEventTypes.POINTERPICK){
        const pick = pi.pickInfo;
        if(pick.hit){
            const asteroid = asteroids.find(a=>a.mesh===pick.pickedMesh);
            if(asteroid){
                camera.lockedTarget = asteroid.mesh;
                highlightAsteroid(asteroid);
            } else {
                camera.lockedTarget = null;
                highlightAsteroid(null);
            }
        } else {
            camera.lockedTarget = null;
            highlightAsteroid(null);
        }
    }
});

// ---------- UPDATE LOOP ----------
let lastTime = performance.now();
scene.registerBeforeRender(()=>{
    const now = performance.now();
    const deltaSec = (now - lastTime)/1000;
    lastTime = now;
    const deltaDays = deltaSec * SIMULATION_SPEED;

    // Earth motion
    earthAngle += EARTH_SPEED * deltaDays;
    earth.position.x = ORBIT_RADIUS * Math.cos(earthAngle);
    earth.position.z = ORBIT_RADIUS * Math.sin(earthAngle);
    earth.rotation.y = earthAngle;

    // Asteroids motion
    asteroids.forEach(a=>{
        a.mesh.rotation.x += a.mesh.rotationSpeed.x;
        a.mesh.rotation.y += a.mesh.rotationSpeed.y;
        a.mesh.rotation.z += a.mesh.rotationSpeed.z;

        a.angle += a.speed * deltaDays;
        a.mesh.position.x = a.radius*Math.cos(a.angle);
        a.mesh.position.y = a.radius*Math.sin(a.angle)*Math.sin(BABYLON.Tools.ToRadians(a.inclination));
        a.mesh.position.z = a.radius*Math.sin(a.angle)*Math.cos(BABYLON.Tools.ToRadians(a.inclination));
    });

    // highlight nearest to Earth
    if(asteroids.length>0){
        const nearest = asteroids.reduce((prev,curr)=>
            (BABYLON.Vector3.Distance(curr.mesh.position, earth.position) < 
             BABYLON.Vector3.Distance(prev.mesh.position, earth.position)) ? curr : prev
        );
        highlightAsteroid(nearest);
    }

    if(highlightedAsteroid){
        document.getElementById("infoPanel").innerHTML =
            `<strong>${highlightedAsteroid.mesh.name}</strong><br>
             Orbit radius: ${highlightedAsteroid.radius.toFixed(1)}<br>
             Inclination: ${highlightedAsteroid.inclination.toFixed(1)}°<br>
             Angular speed: ${(highlightedAsteroid.speed).toFixed(5)} rad/day<br>
             Distance to Earth: ${(BABYLON.Vector3.Distance(highlightedAsteroid.mesh.position, earth.position)).toFixed(2)}<br>
             Click empty space to release camera.`;
    }
});

// ---------- RENDER LOOP ----------
engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
